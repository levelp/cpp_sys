<!-- doc.py -->
Массивы
=======
Одномерные
type arrayName[numberOfElements];
0..numberOfElements-1
``` cpp
  int intArray[10];
  // int - тип элементов массива
  // intArray - название массива
  // 10 - количество элементов
  // Нумерация элементов: 0..9

  // Записываем 23 в первый элемент массива
  intArray[0] = 23;
  intArray[1] = 10; // Второй элемент массива

  cout << intArray[0] + intArray[1] << endl; // 23+10=33

  // Увеличить каждый элемент массива на 10
  for(int i = 0; i < 10; ++i)
    intArray[i] += 10;

  // Поиск минимума в массиве
  int minValue = intValue[0];

  for(int i = 1; i < 10; ++i)
    if(intArray[i] < minValue)
      minValue = intArray[i];

  // Поиск максимума в массиве
  int maxValue = intValue[0];

  for(int i = 1; i < 10; ++i)
    if(intArray[i] > maxValue)
      maxValue = intArray[i];

```

[01_arrays/main.cpp](01_arrays/main.cpp)

Задание: сумма элементов массива
--------------------------------
Ввести с клавиатуры массив целых чисел из 5 элементов,
посчитать сумму элементов и вывести на экран.
Пример ввода (что вводит пользователь):
1 4 5 10 2
Пример вывода (результат - сумма):
22
sum = sum + a[i]
[02_array_task/main.cpp](02_array_task/main.cpp)

Погрешность
Комплексное число - Complex number
3 + 2j
typedef  Описание_типа  Имя_нового_типа;
Вывод комплексного числа на экран
Comp res = {a.re + b.re, a.im + b.im};
1.000000
2.000000 + 1.000000 i
3.000000 + 1.000000 i
[03_struct_C/main.c](03_struct_C/main.c)

Новая сложная структура данных
Точка на плоскости
Задаётся 2-мя координатами: x и y
Операция сложения точек
Расстояние между 2-мя точками
[04_struct_cpp/main.cpp](04_struct_cpp/main.cpp)

По значению - by value - копируется значение
Внутри функции возникает новая переменная i, при изменении которой
"основная" i никак не меняется
По ссылке - by reference
i внутри функции - новое имя (алиас, alias) для внешней переменной
По указателю - by pointer
Сначала она равна 3
[05_value_ref_pointer/main.cpp](05_value_ref_pointer/main.cpp)

Исследование как выглядит в памяти значение выбранного типа
Чтобы синхронно по всей программе менять
тип который мы сейчас исследуем
Разложение по байтам
sizeof(My) - размер типа My в байтах
>> - побитовый сдвиг вправо
[06_show_in_memory_presentation/main.cpp](06_show_in_memory_presentation/main.cpp)

Чтобы понять рекурсию,
надо понять рекурсию.
Рекурсивная функция f
if(N == 0)
return 1;
else
return N * f(N-1);
[07_factorial_rec/main.cpp](07_factorial_rec/main.cpp)

Точка
Сумма
TODO: Реализовать
Разность
TODO: Реализовать
Скалярное произведение векторов
TODO: Реализовать
Тестирование
[HomeWork_1/main.cpp](HomeWork_1/main.cpp)

Домашнее задание - рекурсия
---------------------------
ЗАДАНИЕ:
Пользователь вводит натуральное число N.
Нужно вывести все способы разложить его на слагаемые.
Способы отличающиеся только
порядком слагаемых считаются одинаковыми.

Например N = 4:
4 = 4
4 = 3 + 1
4 = 2 + 2
4 = 2 + 1 + 1
4 = 1 + 1 + 1 + 1
N - число для разложения
m - максимальное слагаемое в сумме
Вводим число N
Вывод разложения на слагаемые
[HomeWork_2/main.cpp](HomeWork_2/main.cpp)

Задача на рекурсию "Скобочные последовательности"
=================================================
На входе: N - количество пар скобок
Вывести все правильные скобочные
последовательности из обычных скобок '(' ')'
{} []
из N пар скобок
Например:
N = 1
Ответ:
()
N = 2
(())
()()
Рекурсивная функция
Уже поставлено:
o - открывающих  с - закрывающих
Всего надо поставить N откр и N закр
Ввод данных
[HomeWork_3/main.cpp](HomeWork_3/main.cpp)

cout << D << "\n\n" << endl;
[hw01/main.cpp](hw01/main.cpp)

if (a==0)
{
std::cout << "Factor a can't be equal 0\n\n ";
goto start;
}
std::cout << "Rownanie kwadratowe :" << a << "x2" << "+" << b << "x" << "+" << c<< "= 0\n\n";
[hw_square/main.cpp](hw_square/main.cpp)

